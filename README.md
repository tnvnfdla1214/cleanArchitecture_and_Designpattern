# 클린아키텍쳐와 디자인 패턴

### Clean Architecture란
먼저 제가 이해한 방향은 디자인 패턴에서 시작되었습니다. 먼저 "디자인 패턴?" 좋다 이겁니다. 그런데 그 디자인 패턴마저 ViewModel이 해야하는 양이 많이지고 너무 비대해지며 예를 들면 BD의 변경시등 변화에 잘 대응하지 못한다는 이해에서 시작되엇습니다. 그랬을때 변화에 잘 대응 할 수있고 의존성의 규칙을 두어 체계적인 구조화를 목표로 CleanArchitecture와 MVVM을 합친 저의 결론을 이번 블로그를 통해 작성할 것 입니다.

### 변화에 잘 대응할 수 있는 코드
변화에 잘 대응하는 것의 결과는 변화에 따른 코드의 변경이 적다는 것이겠죠. 즉, 변화가 일어나는 곳에서만 코드의 변화가 일어나야 합니다. 만약 데이터베이스에서 변화가 일어났는데 액티비티에서 변화가 일어나는 것은 좋지 않을 겁니다. 그러나 코드가 잘 분리돼 있어야 합니다. 그러면 코드를 어떻게 잘 분리해야 할까요? 코드가 본질에 맞게 설계돼 있어야 합니다. 예를 들어 데이터베이스의 테이블을 레이아웃을 구성하는 부분에서 사용한다면 본질에 맞지 않게 설계된 겁니다.그렇다면 모호할 수 있는 본질에 대해 생각해보겠습니다. 먼저 도메인의 본질이 있습니다. 기획자나 실제 사용자가 받아들이는 형태 그 자체를 코드로 작성할 수 있어야 합니다. 뱅크샐러드에서 제공하는 가계부 서비스를 생각해보면, 소비자가 생각하는 지출의 본질과 개념은 바뀌지 않지만, **서비스에서 어떻게 보여줄 것인지만이 바뀔 뿐이죠.** 그러므로 개발은 그 본질을 잘 나타낼 수 있는 방향으로 이뤄져야 합니다. 만약 데이터의 테이블뷰를 뷰모델로 사용한다면, 사용자는 개발자가 테이블 단위로 생각하지 않고 자신이 생각하는 집합 내지 개념 단위로 생각하므로, 변화가 필연적으로 일어납니다.

다음으로 **개발 구조 상의 본질**이 있습니다. 데이터라는 하나의 레벨로 추상화를 했는데, 실제로는 내부에 SharedPreferences, Realm, SQLite를 모두 포함하고 있다면, 구조 상으로 변화가 일어날 수 있는 지점에 대해 생각하지 않고 분리하지 않아 문제가 발생할 수 있습니다. 가령 SharedPreferences를 바꿨는데 Realm을 불러오는 코드에 영향을 미칠 수도 있다면 변화가 일어나는 위치에 대한 고민이 부족했다고 할 수 있습니다.안드로이드 구조 상의 본질도 생각해야 합니다. 만약 화면에 보여주는 뷰의 생명주기를 액티비티에서 관리하므로 이런 부분에 맞게 코드 구조가 설계돼 있어야 합니다.

### Clean Architecture
<img src="https://user-images.githubusercontent.com/48902047/145948874-b29e06a5-8b7b-4d89-b102-8515bb5560fc.png"></img>
<img src="https://user-images.githubusercontent.com/48902047/145949084-1b99a6f1-eac0-4e67-800e-dc6750a7731f.png"></img>
Uncle Bob으로 유명한 Robert Martin의 Clean Architecture를 읽고 안드로이드에 대해서도 고민하게 됐습니다. 양파 모양의 레이어 가장 바깥 쪽이 사용자와의 접접에 있는 Presentation 이고 가장 안쪽의 Entities가 사용자가 실제로 생각하는 개념 단위입니다. Clean Architecture에서는 서버 쪽 내용이지만 안드로이드에서도 이 원리를 적용시켜서 UI를 독립시키고 Database를 분리시키고, 외부적인 설정에 독립적인 구조를 적용하면 프레임워크에 의존적이지 않은 코드를 짤 수 있고, 테스트가 가능한 코드를 짤 수 있는 원리가 될 수 있습니다.

Android에서도 Clean Architecture를 적용하려는 시도가 많습니다. 그 중 가장 유명한 글에서 위 그림처럼 레이어를 네 개로 분리했는데 그것이 클린 아키텍쳐의 근간입니다.

**클린 아키텍처의 목표는 의존성 규칙을 통한 계층 분리**

클린 아키텍처의 구조는 위와 같이 총 4가지 계층으로 되어 있습니다.

이렇게 계층을 나누는 이유는 계층을 분리하여 관심사를 분리시키기 위해서이며 이런 아키텍처가 동작하기 위해서는 **의존성 규칙**을 지켜야 합니다. 한마디로 **각 분리된 클래스가 한가지 역할만 하고 서로 의존을 어떻게 할지 규칙이 정해져있고 지켜야한다는 말**입니다.

여기서 **의존성 규칙은 모든 소스코드 의존성은 반드시 외부에서 내부로, 고수준 정책을 향해야 합니다.** 즉 안드로이드를 예로들면 비즈니스 로직을 담당하는 ViewModel과 같은 코드들이 DB 또는 Web 같이 구체적인 세부 사항에 의존하지 않아야 합니다. 이를 통해 비즈니스 로직(고수준 정책)은 세부 사항들(저수준 정책)의 변경에 영향을 받지 않도록 할 수 있습니다.

이렇게 나눔으로써 얻는 이점들은 다음과 같습니다. 가장 중요한건 Testable과 유지보수 및 협업이라 볼 수 있겠습니다.

+ 코트 테스트 커버리지 증대
+ 쉽게 패키지 구조 탐색 가능
+ 집중화된 클래스에 따른 프로젝트 유지 관리 증대
+ 새 기능을 빠르게 적용 가능
+ 이후의 개발에도 안정적인 구현
+ 명확한 규율로 전반적으로 따라야 할 베스트 프랙티스

위와 같은 설명이 있지만 가장 와닿는것은 ViewModel의 부담을 줄어들 수 있는 점입니다.

MVVM, MVP 구분없이 많은 프로젝트에서 위와 같은 구조로 이루어져 있을 것이라 생각됩니다. 복잡하지 않은 화면에서는 위 구조도 충분히 역할을 다할 수 있습니다. 문제는 스펙 자체가 복잡하거나 Main flow 에 속한 화면일수록 수많은 비즈니스 로직이 존재하거나 늘어나가고 있습니다. 즉, ViewModel 이 집중적으로 비대해지게 되되어 무슨일을 수행하는지 파악하기가 어려워지곤 합니다.

ViewModel 을 만드는 기준을 Activity 가 아닌 개별 View 를 기준으로 만들어보기도 했으나 근본적인 해결책은 되지 못했습니다. 이에 클린 아키텍처에서 주장하는 **도메인 계층**의 필요성이 대두 되습니다. 도메인 계층을 통해 ViewModel 에서 수행되는 비즈니스 로직을 분리하는 것이 목표입니다.

안드로이드 개발을 위한 더 이해하기 쉬운 클린아키텍처 구조 그림도가 있지만 뒤에서 살펴보도록 하고 먼저 오리지널 클린아키텍처의 각 계층의 역할에 대해 설명하면 다음과 같습니다.

### 4 Layers
<img src = "https://user-images.githubusercontent.com/48902047/146732189-bbbaa693-fe81-4363-8ab2-c34cbce3c98f.png">

1. Presenters레이어(Interface Adapters) : Presenters레이어는 데이터를 Entity 및 UseCase의 편리한 형식(Format) 에서 데이터베이스 및 웹에 적용 할 수있는 형식으로 변환합니다. 이 계층에는 MVP의 Presenter, MVVM의 ViewModel 및 게이트웨이 (= Repositories)가 포함됩니다. 즉 순수한 [**비즈니스 로직**](https://github.com/tnvnfdla1214/-Business_logic)(사용자에게 보여지는 로직)만을 담당하는 역할을 하게 됩니다.
2. Data 레이어 : 










1. Entities :  순수한 Java나 Kotlin 모듈로 안드로이드 모듈이 아니므로 안드로이드와의 의존성이 없습니다. 즉, 사용자가 생각하는 형태대로 도메인(비즈니스 로직)에서 파생되는 개념을 표현합니다. 만약 같은 서비스를 만든다면 Android, iOS, 서버 모두 같은 이름과 타입을 사용하는 동일한 형태여야 합니다.
<img src = "https://user-images.githubusercontent.com/48902047/145938704-551d226c-bc91-4201-a4ee-6d58d7f966f9.png" width="50%" height="50%">
소비 내역에 카테고리라는 엔티티를 적용했습니다. 엔티티 레이어에 존재하는 개념으로, 어떤 테이블과 테이블을 조인하는 SQLite의 개념이 여기서는 들어가서는 안됩니다. 만약 그렇게 하면 객체 간의 관계를 지원하는 Realm으로 데이터 레이어를 바꾸는 순간 엔티티 레이어에 영향을 주기 때문입니다.엔티티는 비즈니스 규칙을 캡슐화합니다. 엔티티는 메서드를 갖는 객체일 수도 있지만 데이터 구조와 함수의 집합일 수도 있습니다. 가장 일반적이면서 고수준의 규칙을 캡슐화하게 됩니다. 외부가 변경되더라도 이러한 규칙이 변경될 가능성이 적습니다.

2. Use cases : Use case란 내가 만들고자하는 시스템(혹은 서비스라고 하자)을 사용하는 클라이언트가 **그 시스템을 통해 하고자 하는 것**입니다. 예를 들어, '영화관' 이라는 서비스가 있다고 가정해봅시다. 영화관에서 손님(클라이언트)는 '영화 예매'를 할 수도 있고, '예매 취소'를 할 수도 있고, '환불', 심지어 '팝콘 사기'를 할 수도 있을 것입니다. 이 때, 이런 '영화 예매', '예매 취소', '환불', '팝콘 사기' 등등이, '영화관'이라는 시스템에 사용자가 요청할 수 있는, '영화관'의 Use case이다. Use Case는 이름만 보고 이게 무슨 기능을 가졌을지 짐작하고 구분할 수 있어야합니다.
<img src = "https://user-images.githubusercontent.com/48902047/145939602-c0e77696-4682-4a6d-8338-a1c8f0d03d46.png">

3. Interface Adapters (Presenters) : 인터페이스 어댑터는 데이터를 Entity 및 UseCase의 편리한 형식(Format) 에서 데이터베이스 및 웹에 적용 할 수있는 형식으로 변환합니다. 이 계층에는 MVP의 Presenter, MVVM의 ViewModel 및 게이트웨이 (= Repositories)가 포함됩니다. 즉 순수한 [**비즈니스 로직**](https://github.com/tnvnfdla1214/-Business_logic)(사용자에게 보여지는 로직)만을 담당하는 역할을 하게 됩니다.
4. Frameworks & Drivers (Web, DB) : 프레임워크와 드라이버는 웹 프레임 워크, 데이터베이스, UI, HTTP 클라이언트 등으로 구성된 가장 바깥 쪽 계층입니다.

 그림과 설명을 보고도 실제 안드로이드에서 사용하는 아키텍처 구조와 좀 다른 용어와 레이어 구조 때문에 햇갈릴 수 도 있을 겁니다. 예를들어 MVVM, MVP 같은 아키텍처를 주로 사용하는 안드로이드에서는 대부분 Entity 레이어 나누지 않고 Controller(인터페이스 어댑터) 등 직접적으로 접하지 않는 용어들이 사용되기 때문입니다. 또한 가장 바깥계층인  Frameworks & Drivers 에  DB, Web과 함께 UI 도 포함되어 있으므로 혼란을 일으킬 수 있습니다.

그래서 다음과 같이 안드로이드에 맞춘 이해하기 쉽게 그린 클린아키텍처 구조 그림들이 있습니다.

#### MVP architecture
<img src="https://user-images.githubusercontent.com/48902047/142761165-bfb23b01-0e13-4609-8aac-6422e0b7a02b.png"></img>
#### Clean Artitecture 구조도
<img src="https://user-images.githubusercontent.com/48902047/142761182-0b99f655-4c4a-48bc-89c6-d33c4a8a1eb0.png"></img>
<img src="https://user-images.githubusercontent.com/48902047/145948768-c8fe4732-f0e6-4f08-8c96-dc3110cddfa5.png"></img>
<img src="https://user-images.githubusercontent.com/48902047/145948874-b29e06a5-8b7b-4d89-b102-8515bb5560fc.png"></img>
<img src="https://user-images.githubusercontent.com/48902047/145949084-1b99a6f1-eac0-4e67-800e-dc6750a7731f.png"></img>

안드로이드용으로 이해하기 쉽게 만들어진 클린아키텍처 구조는 Entity 레이러를 따로 두지않고 일반적으로 Presentation, Domain, Data 총 3개의 계층으로 크게 나눠지게 됩니다. 그리고 바로 위 그림을 보면 알 수 있듯이 Presentation -> Domain 방향으로 의존성이 있습니다.

1. Presentation : UI(Activity, Fragment), Presenter 및 ViewModel을 포함합니다. 즉 화면과 입력에 대한 처리 등 UI와 직접적으로 관련된 부분을 담당합니다. 또한 Presentation 레이어는 Domain과 Data 레이어를 포함하고 있다는 특징이 있습니다.
2. Domain : 애플리케이션의 비즈니스 로직을 포함하고 비즈니스 로직에서 필요한 Model 과 UseCase를 포함하고 있습니다.
3. Data : Repositoy 구현체, Cache, Room DB, Dao, Model 서버API(Retrofit2) 을 포함하고 있으며 로컬 또는 서버 API와 통신하여 데이터를 CRUD 하는 역할을 합니다. 또한 Mapper 클래스도 포함하고 있는데 DB로 부터 받아온 데이터모델과 UI에 맞는 데이터모델간의 변환을 해주는 역할을 합니다. 추가로 Domain 레이어를 포함하고있다는 특징이 있습니다.
