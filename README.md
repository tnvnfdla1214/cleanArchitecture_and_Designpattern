# 클린아키텍쳐와 디자인 패턴

### Clean Architecture란
 고객들에게 제공하는 애플리케이션 같은 경우에는 수많은 기능들이 있기에 복잡도가 굉장히 높습니다. 복잡도가 높은 애플리케이션을 개발할 때 어떻게 하면 유지 보수하기 쉽고 고품질의 코드를 작성할 수 있을까요? 애플리케이션은 새로운 기능이 추가된다거나 내부 로직이 변경되어야 하는 일이 생겼을 때 유연하게 대처할 수 있도록 구조화해야 합니다.

**클린 아키텍처의 목표는 의존성 규칙을 통한 계층 분리**

관심사를 분리하는 것이 무슨 의미가 있을까요?

 예를 한번 들어보겠습니다. 안드로이드 로컬 DB를 기존에 Realm을 사용하고 있었습니다. Realm으로 수많은 기능을 구현하고 이미 제품까지 나와 있는 상황입니다. 그런데 갑자기 묻지도 따지지도 않고 로컬 DB를 Room으로 교체해야 한다고 합니다. 이미 프로젝트 복잡도가 높아져서 Realm에서 Room으로 바꾸기엔 쉽지 않을 것 같습니다. Realm 인스턴스를 전부 Room 인스턴스로 변경한 뒤, 그에 맞게 또 대처를 해줘야 합니다. 클린 아키텍처로 프로젝트 구조를 잡는다면 변화에 유연하게 코드를 작성할 수 있습니다.
 
 <img src = "https://user-images.githubusercontent.com/48902047/145936229-bb5c0d04-8942-4fc1-b0e3-093aac00582b.png">

클린 아키텍처의 구조는 위와 같이 총 4가지 계층으로 되어 있습니다.

이렇게 계층을 나누는 이유는 계층을 분리하여 관심사를 분리시키기 위해서이며 이런 아키텍처가 동작하기 위해서는 **의존성 규칙**을 지켜야 합니다. 한마디로 **각 분리된 클래스가 한가지 역할만 하고 서로 의존을 어떻게 할지 규칙이 정해져있고 지켜야한다는 말**입니다.

여기서 **의존성 규칙은 모든 소스코드 의존성은 반드시 외부에서 내부로, 고수준 정책을 향해야 합니다.** 즉 안드로이드를 예로들면 비즈니스 로직을 담당하는 ViewModel과 같은 코드들이 DB 또는 Web 같이 구체적인 세부 사항에 의존하지 않아야 합니다. 이를 통해 비즈니스 로직(고수준 정책)은 세부 사항들(저수준 정책)의 변경에 영향을 받지 않도록 할 수 있습니다.

이렇게 나눔으로써 얻는 이점들은 다음과 같습니다. 가장 중요한건 Testable과 유지보수 및 협업이라 볼 수 있겠습니다.

+ 코트 테스트 커버리지 증대
+ 쉽게 패키지 구조 탐색 가능
+ 집중화된 클래스에 따른 프로젝트 유지 관리 증대
+ 새 기능을 빠르게 적용 가능
+ 이후의 개발에도 안정적인 구현
+ 명확한 규율로 전반적으로 따라야 할 베스트 프랙티스

위와 같은 설명이 있지만 가장 와닿는것은 ViewModel의 부담을 줄어들 수 있는 점입니다.

<img src = "https://user-images.githubusercontent.com/48902047/145937347-cc613cdb-8386-4d26-a870-e9f38811c8f2.png">
 
MVVM, MVP 구분없이 많은 프로젝트에서 위와 같은 구조로 이루어져 있을 것이라 생각됩니다. 복잡하지 않은 화면에서는 위 구조도 충분히 역할을 다할 수 있습니다. 문제는 스펙 자체가 복잡하거나 Main flow 에 속한 화면일수록 수많은 비즈니스 로직이 존재하거나 늘어나가고 있습니다. 즉, ViewModel 이 집중적으로 비대해지게 되되어 무슨일을 수행하는지 파악하기가 어려워지곤 합니다.

ViewModel 을 만드는 기준을 Activity 가 아닌 개별 View 를 기준으로 만들어보기도 했으나 근본적인 해결책은 되지 못했습니다. 이에 클린 아키텍처에서 주장하는 **도메인 계층**의 필요성이 대두 되습니다. 도메인 계층을 통해 ViewModel 에서 수행되는 비즈니스 로직을 분리하는 것이 목표입니다.

안드로이드 개발을 위한 더 이해하기 쉬운 클린아키텍처 구조 그림도가 있지만 뒤에서 살펴보도록 하고 먼저 오리지널 클린아키텍처의 각 계층의 역할에 대해 설명하면 다음과 같습니다.

1. Entities :  순수한 Java나 Kotlin 모듈로 안드로이드 모듈이 아니므로 안드로이드와의 의존성이 없습니다. 즉, 사용자가 생각하는 형태대로 도메인(비즈니스 로직)에서 파생되는 개념을 표현합니다. 만약 같은 서비스를 만든다면 Android, iOS, 서버 모두 같은 이름과 타입을 사용하는 동일한 형태여야 합니다.
<img src = "https://user-images.githubusercontent.com/48902047/145938704-551d226c-bc91-4201-a4ee-6d58d7f966f9.png" width="50%" height="50%">
소비 내역에 카테고리라는 엔티티를 적용했습니다. 엔티티 레이어에 존재하는 개념으로, 어떤 테이블과 테이블을 조인하는 SQLite의 개념이 여기서는 들어가서는 안됩니다. 만약 그렇게 하면 객체 간의 관계를 지원하는 Realm으로 데이터 레이어를 바꾸는 순간 엔티티 레이어에 영향을 주기 때문입니다.엔티티는 비즈니스 규칙을 캡슐화합니다. 엔티티는 메서드를 갖는 객체일 수도 있지만 데이터 구조와 함수의 집합일 수도 있습니다. 가장 일반적이면서 고수준의 규칙을 캡슐화하게 됩니다. 외부가 변경되더라도 이러한 규칙이 변경될 가능성이 적습니다.

2. Use cases : Use case란 내가 만들고자하는 시스템(혹은 서비스라고 하자)을 사용하는 클라이언트가 **그 시스템을 통해 하고자 하는 것**입니다. 예를 들어, '영화관' 이라는 서비스가 있다고 가정해봅시다. 영화관에서 손님(클라이언트)는 '영화 예매'를 할 수도 있고, '예매 취소'를 할 수도 있고, '환불', 심지어 '팝콘 사기'를 할 수도 있을 것입니다. 이 때, 이런 '영화 예매', '예매 취소', '환불', '팝콘 사기' 등등이, '영화관'이라는 시스템에 사용자가 요청할 수 있는, '영화관'의 Use case이다. Use Case는 이름만 보고 이게 무슨 기능을 가졌을지 짐작하고 구분할 수 있어야합니다.
<img src = "https://user-images.githubusercontent.com/48902047/145939602-c0e77696-4682-4a6d-8338-a1c8f0d03d46.png">

3. Interface Adapters (Presenters) : 인터페이스 어댑터는 데이터를 Entity 및 UseCase의 편리한 형식(Format) 에서 데이터베이스 및 웹에 적용 할 수있는 형식으로 변환합니다. 이 계층에는 MVP의 Presenter, MVVM의 ViewModel 및 게이트웨이 (= Repositories)가 포함됩니다. 즉 순수한 **비즈니스 로직**만을 담당하는 역할을 하게 됩니다.
4. Frameworks & Drivers (Web, DB) : 프레임워크와 드라이버는 웹 프레임 워크, 데이터베이스, UI, HTTP 클라이언트 등으로 구성된 가장 바깥 쪽 계층입니다.

 그림과 설명을 보고도 실제 안드로이드에서 사용하는 아키텍처 구조와 좀 다른 용어와 레이어 구조 때문에 햇갈릴 수 도 있을 겁니다. 예를들어 MVVM, MVP 같은 아키텍처를 주로 사용하는 안드로이드에서는 대부분 Entity 레이어 나누지 않고 Controller(인터페이스 어댑터) 등 직접적으로 접하지 않는 용어들이 사용되기 때문입니다. 또한 가장 바깥계층인  Frameworks & Drivers 에  DB, Web과 함께 UI 도 포함되어 있으므로 혼란을 일으킬 수 있습니다.

그래서 다음과 같이 안드로이드에 맞춘 이해하기 쉽게 그린 클린아키텍처 구조 그림들이 있습니다.

#### MVP architecture
<img src="https://user-images.githubusercontent.com/48902047/142761165-bfb23b01-0e13-4609-8aac-6422e0b7a02b.png"></img>
#### Clean Artitecture 구조도
<img src="https://user-images.githubusercontent.com/48902047/142761182-0b99f655-4c4a-48bc-89c6-d33c4a8a1eb0.png"></img>
<img src="https://user-images.githubusercontent.com/48902047/145948768-c8fe4732-f0e6-4f08-8c96-dc3110cddfa5.png"></img>
<img src="https://user-images.githubusercontent.com/48902047/145948874-b29e06a5-8b7b-4d89-b102-8515bb5560fc.png"></img>
<img src="https://user-images.githubusercontent.com/48902047/145949084-1b99a6f1-eac0-4e67-800e-dc6750a7731f.png"></img>

안드로이드용으로 이해하기 쉽게 만들어진 클린아키텍처 구조는 Entity 레이러를 따로 두지않고 일반적으로 Presentation, Domain, Data 총 3개의 계층으로 크게 나눠지게 됩니다. 그리고 바로 위 그림을 보면 알 수 있듯이 Presentation -> Domain 방향으로 의존성이 있습니다.

1. Presentation : UI(Activity, Fragment), Presenter 및 ViewModel을 포함합니다. 즉 화면과 입력에 대한 처리 등 UI와 직접적으로 관련된 부분을 담당합니다. 또한 Presentation 레이어는 Domain과 Data 레이어를 포함하고 있다는 특징이 있습니다.
2. Domain : 애플리케이션의 비즈니스 로직을 포함하고 비즈니스 로직에서 필요한 Model 과 UseCase를 포함하고 있습니다.
3. Data : Repositoy 구현체, Cache, Room DB, Dao, Model 서버API(Retrofit2) 을 포함하고 있으며 로컬 또는 서버 API와 통신하여 데이터를 CRUD 하는 역할을 합니다. 또한 Mapper 클래스도 포함하고 있는데 DB로 부터 받아온 데이터모델과 UI에 맞는 데이터모델간의 변환을 해주는 역할을 합니다. 추가로 Domain 레이어를 포함하고있다는 특징이 있습니다.

##### 참고 : 비지니스 로직이란
홈페이지 회원가입으로 예를 들어봅시다.

유저는 회원가입 양식 폼에 회원정보를 작성하고, 회원가입 버튼을 누르면 회원가입이 진행됩니다. 이 과정 중 아이디 중복 검사, 본인 인증, 비밀번호 재 검사 등 유저가 통과해야 할 것이 많습니다. 

유저는 단순한 버튼 클릭으로 아이디 중복인지 아닌지,본인의 인증이 올바른지, 비밀번호 가 올바른지 등등을  홈페이지의 글이나, 다이얼로그로 확인합니다.

유저 입장에선 아무렇지 않게 확인하고 있는 것 들이지만, 

프로그래머는 위에 일련의 인증할 것들을 구현하기 위해서는 생각보다 많은 수고를 들입니다.

프로그래머 입장에 서서, 영역을 나누어 보겠습니다.

위의 아이디 중복 검사를 예시로 들자면, 프로그래머는 유저가 입력한 아이디가 회원 중 아이디를 중복으로 쓰고 있는지 검사하기 위해 데이터베이스를 조사합니다. 데이터베이스를 조사 후, 중복 아이디가 없다면 유저에게 페이지 속 글 또는 다이얼로그로 아이디를 사용해도 된다는 표시를 해줍니다.

여기서 크게 2영역으로 나눌 수 있습니다. 

하나는 중복 아이디가 있는지 없는지를 검사하기위한 일련의 과정들 ( 1번째 영역 )

나머지는,  유저에게 단순히 텍스트나 다이얼로그로 알려주는 것이 있습니다. ( 2번째 영역 )

2번째 영역은 흔히, Presentation 영역 혹은 View 영역 이라고 많이 불리우는데, 가공된 데이터를 단순히 표시만 해주는 것입니다. (ex 아이디가 중복됬습니다 표시, 비밀번호 재 검사를 실패 했습니다. 등등) 그 데이터 가공을 담당하는것이 1번째 영역 흔히들 Logic 영역, Model 영역이라 불립니다.

위에서 소개한 영역 2가지 중, 첫번째 영역에서의 코딩을 흔히, 비지니스 로직이라 부릅니다.

위의 아이디 중복찾기를 다시 예시로 들자면, 아래와 같은 비지니스 로직이 작성될 것입니다.

+ 회원이 작성한 아이디 값 저장하기 -> 회원정보가 있는 데이터베이스 연결 ->데이터베이스에 회원이 작성한 아이디 값이 있는지 Select -> 회원의 아이디가 이미 있는지 없는지 여부를 데이터화 하여 저장 -> 데이터베이스 연결 끊기 -> View영역에게 가공된 데이터 전달
이러한 비지니스 로직은 유저 눈엔 보이진 않지만, 유저가 바라는 결과물을 올바르게 도출하기 위해 코드로 짜여집니다.

즉, 프로그래머는 유저가 원하는 행위를 컴퓨터에게 잘 전달하기 위해서는 비즈니즈 로직을 잘 구상해야 한다는 의미입니다.

