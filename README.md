# 클린아키텍쳐와 디자인 패턴

### Clean Architecture란
 고객들에게 제공하는 애플리케이션 같은 경우에는 수많은 기능들이 있기에 복잡도가 굉장히 높습니다. 복잡도가 높은 애플리케이션을 개발할 때 어떻게 하면 유지 보수하기 쉽고 고품질의 코드를 작성할 수 있을까요? 애플리케이션은 새로운 기능이 추가된다거나 내부 로직이 변경되어야 하는 일이 생겼을 때 유연하게 대처할 수 있도록 구조화해야 합니다.

**클린 아키텍처의 목표는 의존성 규칙을 통한 계층 분리**

관심사를 분리하는 것이 무슨 의미가 있을까요?

 예를 한번 들어보겠습니다. 안드로이드 로컬 DB를 기존에 Realm을 사용하고 있었습니다. Realm으로 수많은 기능을 구현하고 이미 제품까지 나와 있는 상황입니다. 그런데 갑자기 묻지도 따지지도 않고 로컬 DB를 Room으로 교체해야 한다고 합니다. 이미 프로젝트 복잡도가 높아져서 Realm에서 Room으로 바꾸기엔 쉽지 않을 것 같습니다. Realm 인스턴스를 전부 Room 인스턴스로 변경한 뒤, 그에 맞게 또 대처를 해줘야 합니다. 클린 아키텍처로 프로젝트 구조를 잡는다면 변화에 유연하게 코드를 작성할 수 있습니다.
 
 <img src = "https://user-images.githubusercontent.com/48902047/145936229-bb5c0d04-8942-4fc1-b0e3-093aac00582b.png">

클린 아키텍처의 구조는 위와 같이 총 4가지 계층으로 되어 있습니다.

이렇게 계층을 나누는 이유는 계층을 분리하여 관심사를 분리시키기 위해서이며 이런 아키텍처가 동작하기 위해서는 **의존성 규칙**을 지켜야 합니다. 한마디로 **각 분리된 클래스가 한가지 역할만 하고 서로 의존을 어떻게 할지 규칙이 정해져있고 지켜야한다는 말**입니다.

여기서 **의존성 규칙은 모든 소스코드 의존성은 반드시 외부에서 내부로, 고수준 정책을 향해야 합니다.** 즉 안드로이드를 예로들면 비즈니스 로직을 담당하는 ViewModel과 같은 코드들이 DB 또는 Web 같이 구체적인 세부 사항에 의존하지 않아야 합니다. 이를 통해 비즈니스 로직(고수준 정책)은 세부 사항들(저수준 정책)의 변경에 영향을 받지 않도록 할 수 있습니다.

이렇게 나눔으로써 얻는 이점들은 다음과 같습니다. 가장 중요한건 Testable과 유지보수 및 협업이라 볼 수 있겠습니다.

+ 코트 테스트 커버리지 증대
+ 쉽게 패키지 구조 탐색 가능
+ 집중화된 클래스에 따른 프로젝트 유지 관리 증대
+ 새 기능을 빠르게 적용 가능
+ 이후의 개발에도 안정적인 구현
+ 명확한 규율로 전반적으로 따라야 할 베스트 프랙티스

위와 같은 설명이 있지만 가장 와닿는것은 ViewModel의 부담을 줄어들 수 있는 점입니다.

<img src = "https://user-images.githubusercontent.com/48902047/145937347-cc613cdb-8386-4d26-a870-e9f38811c8f2.png">
 
MVVM, MVP 구분없이 많은 프로젝트에서 위와 같은 구조로 이루어져 있을 것이라 생각됩니다. 복잡하지 않은 화면에서는 위 구조도 충분히 역할을 다할 수 있습니다. 문제는 스펙 자체가 복잡하거나 Main flow 에 속한 화면일수록 수많은 비즈니스 로직이 존재하거나 늘어나가고 있습니다. 즉, ViewModel 이 집중적으로 비대해지게 되되어 무슨일을 수행하는지 파악하기가 어려워지곤 합니다.

ViewModel 을 만드는 기준을 Activity 가 아닌 개별 View 를 기준으로 만들어보기도 했으나 근본적인 해결책은 되지 못했습니다. 이에 클린 아키텍처에서 주장하는 **도메인 계층**의 필요성이 대두 되습니다. 도메인 계층을 통해 ViewModel 에서 수행되는 비즈니스 로직을 분리하는 것이 목표입니다.

안드로이드 개발을 위한 더 이해하기 쉬운 클린아키텍처 구조 그림도가 있지만 뒤에서 살펴보도록 하고 먼저 오리지널 클린아키텍처의 각 계층의 역할에 대해 설명하면 다음과 같습니다.

1. Entities :  순수한 Java나 Kotlin 모듈로 안드로이드 모듈이 아니므로 안드로이드와의 의존성이 없습니다. 즉, 사용자가 생각하는 형태대로 도메인(비즈니스 로직)에서 파생되는 개념을 표현합니다. 만약 같은 서비스를 만든다면 Android, iOS, 서버 모두 같은 이름과 타입을 사용하는 동일한 형태여야 합니다.
<img src = "https://user-images.githubusercontent.com/48902047/145938704-551d226c-bc91-4201-a4ee-6d58d7f966f9.png" width="50%" height="50%">
소비 내역에 카테고리라는 엔티티를 적용했습니다. 엔티티 레이어에 존재하는 개념으로, 어떤 테이블과 테이블을 조인하는 SQLite의 개념이 여기서는 들어가서는 안됩니다. 만약 그렇게 하면 객체 간의 관계를 지원하는 Realm으로 데이터 레이어를 바꾸는 순간 엔티티 레이어에 영향을 주기 때문입니다.엔티티는 비즈니스 규칙을 캡슐화합니다. 엔티티는 메서드를 갖는 객체일 수도 있지만 데이터 구조와 함수의 집합일 수도 있습니다. 가장 일반적이면서 고수준의 규칙을 캡슐화하게 됩니다. 외부가 변경되더라도 이러한 규칙이 변경될 가능성이 적습니다.

2. Use cases : Use case란 내가 만들고자하는 시스템(혹은 서비스라고 하자)을 사용하는 클라이언트가 **그 시스템을 통해 하고자 하는 것**입니다. 예를 들어, '영화관' 이라는 서비스가 있다고 가정해봅시다. 영화관에서 손님(클라이언트)는 '영화 예매'를 할 수도 있고, '예매 취소'를 할 수도 있고, '환불', 심지어 '팝콘 사기'를 할 수도 있을 것입니다. 이 때, 이런 '영화 예매', '예매 취소', '환불', '팝콘 사기' 등등이, '영화관'이라는 시스템에 사용자가 요청할 수 있는, '영화관'의 Use case이다. Use Case는 이름만 보고 이게 무슨 기능을 가졌을지 짐작하고 구분할 수 있어야합니다.
<img src = "https://user-images.githubusercontent.com/48902047/145939602-c0e77696-4682-4a6d-8338-a1c8f0d03d46.png">

3. Interface Adapters (Presenters) : 인터페이스 어댑터는 데이터를 Entity 및 UseCase의 편리한 형식(Format) 에서 데이터베이스 및 웹에 적용 할 수있는 형식으로 변환합니다. 이 계층에는 MVP의 Presenter, MVVM의 ViewModel 및 게이트웨이 (= Repositories)가 포함됩니다. 즉 순수한 **비즈니스 로직**만을 담당하는 역할을 하게 됩니다.
4. Frameworks & Drivers (Web, DB) : 프레임워크와 드라이버는 웹 프레임 워크, 데이터베이스, UI, HTTP 클라이언트 등으로 구성된 가장 바깥 쪽 계층입니다.

 그림과 설명을 보고도 실제 안드로이드에서 사용하는 아키텍처 구조와 좀 다른 용어와 레이어 구조 때문에 햇갈릴 수 도 있을 겁니다. 예를들어 MVVM, MVP 같은 아키텍처를 주로 사용하는 안드로이드에서는 대부분 Entity 레이어 나누지 않고 Controller(인터페이스 어댑터) 등 직접적으로 접하지 않는 용어들이 사용되기 때문입니다. 또한 가장 바깥계층인  Frameworks & Drivers 에  DB, Web과 함께 UI 도 포함되어 있으므로 혼란을 일으킬 수 있습니다.

그래서 다음과 같이 안드로이드에 맞춘 이해하기 쉽게 그린 클린아키텍처 구조 그림들이 있습니다.

#### MVP architecture
<img src="https://user-images.githubusercontent.com/48902047/142761165-bfb23b01-0e13-4609-8aac-6422e0b7a02b.png"></img>
#### Clean Artitecture 구조도
<img src="https://user-images.githubusercontent.com/48902047/142761182-0b99f655-4c4a-48bc-89c6-d33c4a8a1eb0.png"></img>
<img src="https://user-images.githubusercontent.com/48902047/145948768-c8fe4732-f0e6-4f08-8c96-dc3110cddfa5.png"></img>
<img src="https://user-images.githubusercontent.com/48902047/145948874-b29e06a5-8b7b-4d89-b102-8515bb5560fc.png"></img>
<img src="https://user-images.githubusercontent.com/48902047/145949084-1b99a6f1-eac0-4e67-800e-dc6750a7731f.png"></img>

안드로이드용으로 이해하기 쉽게 만들어진 클린아키텍처 구조는 Entity 레이러를 따로 두지않고 일반적으로 Presentation, Domain, Data 총 3개의 계층으로 크게 나눠지게 됩니다. 그리고 바로 위 그림을 보면 알 수 있듯이 Presentation -> Domain 방향으로 의존성이 있습니다.

1. Presentation : UI(Activity, Fragment), Presenter 및 ViewModel을 포함합니다. 즉 화면과 입력에 대한 처리 등 UI와 직접적으로 관련된 부분을 담당합니다. 또한 Presentation 레이어는 Domain과 Data 레이어를 포함하고 있다는 특징이 있습니다.
2. Domain : 애플리케이션의 비즈니스 로직을 포함하고 비즈니스 로직에서 필요한 Model 과 UseCase를 포함하고 있습니다.
3. Data : Repositoy 구현체, Cache, Room DB, Dao, Model 서버API(Retrofit2) 을 포함하고 있으며 로컬 또는 서버 API와 통신하여 데이터를 CRUD 하는 역할을 합니다. 또한 Mapper 클래스도 포함하고 있는데 DB로 부터 받아온 데이터모델과 UI에 맞는 데이터모델간의 변환을 해주는 역할을 합니다. 추가로 Domain 레이어를 포함하고있다는 특징이 있습니다.
